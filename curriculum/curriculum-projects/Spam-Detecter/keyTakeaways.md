### `.match()`
-> a string method which accepts a regular expression as an argument and determines if the string matches the expression
### `.test()` 
-> Syntax: regexVariable.test(testSubjectVariable);
### `arrayVariable.some(arg)`
 checks if testing arg on any of the element of arrayVariable returns true. Take Step 12 from the Curriculum Project for example. This line of code: 
```
   const isSpam = (msg) => denyList.some((regex) => regex.test(msg));
``` 
means, in plain language, that the `isSpam` function variable stores a value of true or false; it takes `msg` as a parameter, and does something with it in the following execution statements: <br><br> first, call the `.some()` method on the array `denyList` which contains regular expressions (short: regex) that are used to "detect" whether user inputs are spams. There are many ways of doing this. Using the `.some()` method is only one of many. This method takes a *function* as an argument and returns a value of true or false. <br><br>In our case, the *function* argument is `(regex) => regex.test(msg);`. This callback function implicitly returns the result of `regex.test(msg)` if it is true; or else, it returns false. <br><br>What does this function do?<br><br> It takes `regex` as a parameter and call `.test()` method on `regex` which passes `msg` as its argument. What this execution does is this: `regex.test(msg)` tests each `regex` from the array `denyList` by checking whether `msg` contain any of these `regex` from the array list `denyList`. <br><br>If `msg` matches any `regex` in `denyList`; the callback function should return true; if not match is found, it should return false.<br><br>Afterwards, the value of true or false will be stored in the `isSpam` function, thus we know that if `isSpam` has or returns the value of true, there is spam contained in the message (`msg`); and if `isSpam` has or returns the value of false, there is no spam detected, at least according to the *given* definition of spam (every `regex` in `denyList`).  
### character class [a-z], [0-9]
Example: const freeRegex = /(?:^|\s)fr[e3][e3] m[o0]n[e3]y(?:$|\s)/i;
- A *character class* is defined by [] (square brackets) and matches *any* character within the brackets; A character class can more than one character. 
- the "+" qualifier matches one or more consecutive occurence. e.g. `/a/+` matches one or more *consecutive* `a` characters.
- the "a|b" qualifier allows string character(s) `a` *or* `b`. e.g. `hundred|thousand|million|` will be detected.
- A *capture group* is a way to define a part of a regex that should be captured and *saved for later reference*. You wrap it in "()" parentheses. e.g. /h(i|hey) humans/ would match "hi humans" or "hey humans". Not using a *capture groupd* will still match but not remember them so that you won't be able to reference them later to make specific changes to them, and so on.
- A *non-capture group* allows grouping characters together without preserving the result, using "?:" after the opening parenthesis. e.g. (?:a|b) will match either a or b, but it will not *capture* the result. (I am not sure what it means to not capture the result)
- A "?" symbol marks a part of a regex that is optional for capture; add "?" to the end of a capture groupd. e.g. (......)?
- meta character -> denoted by "\" to match *whole words* instead of "partial words": e.g. while "perfect chance for earning free money" should be a target, "hands-free money management" should not. We can introduce checking spaces between (before and after) words to avoid this. 
- the "\s" token will match spaces, tabs, and line breaks.
- use "^" (anchor tag) to match the beginning of a full string, which asserts that your pattern match starts at the beginning of the *full string*.
use "$" (dollar sign) to match the end of a full string. Without it, "free money" (no space behind "y") will not be detected as spam, while "free money " (with a space) will be recognized as spam.  Adding "$" ensures that "free money" will be captured. 

## Thoughts
* For me, the difficult part is how to define spams. The definitions have been provided in advance for this curriculum project. The real difficulty as I see lies in actually knowing as many types of structure of spams as possible. So, research is unavoidable if the goal is to create a spam detecter at scale. While I am aware this curriculum is meant for learning (some common) syntax of regular expressions, I can't help but wonder about the challenges that go beyond the scope of curriculum once they are put in the context of real software development. 
* Where to apply regex besides detecting spam? It is useful to use regex to detect spams because regex offers user-defined ways of detection/matching/etc. Why do we use regex to match something? Because we are looking for something. The nature of using regex is then universal: searching for something specific. Which makes me wonder if there are use cases in which the goal is not to search for something specific. (research later)
* What other useful regex patterns are there? Sure, but I must resist the impulse to learn everything about one specific programming feature, as I've learned it the hard way: wasting too much time on memorizing things that I forget later. Not every syntax of a specific featrue must be learned by heart or known before actually using it. When you need to use it, only research and look it up then. That would be more practical. Because it is very likely that you will forget if a bulk of what you've memorized remains unapplied.  